-- =====================================================
-- User Management Schema
-- =====================================================
-- This schema supports the complete user management system
-- including profiles, role-based permissions, and audit logs
-- =====================================================

-- =====================================================
-- 1. USER PROFILES TABLE
-- =====================================================
-- Stores user profile information linked to Supabase auth.users
CREATE TABLE IF NOT EXISTS user_profiles (
  id UUID NOT NULL,
  email TEXT NOT NULL,
  name TEXT NULL,
  role TEXT NULL DEFAULT 'member'::text,
  created_at TIMESTAMPTZ NOT NULL DEFAULT TIMEZONE('utc'::text, NOW()),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT TIMEZONE('utc'::text, NOW()),
  last_login TIMESTAMPTZ NULL,
  CONSTRAINT user_profiles_pkey PRIMARY KEY (id),
  CONSTRAINT user_profiles_email_key UNIQUE (email),
  CONSTRAINT user_profiles_id_fkey FOREIGN KEY (id) REFERENCES auth.users(id) ON DELETE CASCADE
) TABLESPACE pg_default;

-- Index for faster lookups
CREATE INDEX IF NOT EXISTS idx_user_profiles_last_login ON user_profiles USING btree (last_login) TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS idx_user_profiles_email ON user_profiles USING btree (email) TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS idx_user_profiles_role ON user_profiles USING btree (role) TABLESPACE pg_default;

-- =====================================================
-- 2. USER PERMISSIONS TABLE
-- =====================================================
-- Stores granular permissions for each user per screen
CREATE TABLE IF NOT EXISTS user_permissions (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  user_id UUID NOT NULL,
  screen_name TEXT NOT NULL,
  can_read BOOLEAN DEFAULT false,
  can_write BOOLEAN DEFAULT false,
  can_manage BOOLEAN DEFAULT false,
  created_at TIMESTAMPTZ NOT NULL DEFAULT TIMEZONE('utc'::text, NOW()),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT TIMEZONE('utc'::text, NOW()),
  CONSTRAINT user_permissions_pkey PRIMARY KEY (id),
  CONSTRAINT user_permissions_user_id_screen_name_key UNIQUE (user_id, screen_name),
  CONSTRAINT user_permissions_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE
) TABLESPACE pg_default;

-- Index for faster permission lookups
CREATE INDEX IF NOT EXISTS idx_user_permissions_user_id ON user_permissions USING btree (user_id) TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS idx_user_permissions_screen_name ON user_permissions USING btree (screen_name) TABLESPACE pg_default;

-- =====================================================
-- 3. AUDIT LOGS TABLE
-- =====================================================
-- Tracks all user actions for security and compliance
CREATE TABLE IF NOT EXISTS audit_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES user_profiles(id) ON DELETE SET NULL,
  action VARCHAR(100) NOT NULL,
  table_name VARCHAR(100),
  record_id TEXT,
  old_values TEXT,
  new_values TEXT,
  ip_address VARCHAR(45),
  user_agent TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes for audit log queries
CREATE INDEX IF NOT EXISTS idx_audit_logs_user_id ON audit_logs(user_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_action ON audit_logs(action);
CREATE INDEX IF NOT EXISTS idx_audit_logs_table_name ON audit_logs(table_name);
CREATE INDEX IF NOT EXISTS idx_audit_logs_created_at ON audit_logs(created_at DESC);

-- =====================================================
-- 4. TRIGGERS
-- =====================================================

-- Trigger to update updated_at timestamp on user_profiles (uses existing function)
DROP TRIGGER IF EXISTS update_user_profiles_updated_at ON user_profiles;
CREATE TRIGGER update_user_profiles_updated_at
  BEFORE UPDATE ON user_profiles
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- Trigger to update updated_at timestamp (uses existing function)
DROP TRIGGER IF EXISTS update_user_permissions_updated_at ON user_permissions;
CREATE TRIGGER update_user_permissions_updated_at
  BEFORE UPDATE ON user_permissions
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- =====================================================
-- 5. HELPER FUNCTION TO AVOID RECURSION
-- =====================================================
-- Function to check if user is admin without causing recursion
CREATE OR REPLACE FUNCTION is_admin_user(user_id UUID)
RETURNS BOOLEAN AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM user_profiles
    WHERE id = user_id AND role = 'admin'
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to check if user is admin or manager
CREATE OR REPLACE FUNCTION is_admin_or_manager(user_id UUID)
RETURNS BOOLEAN AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM user_profiles
    WHERE id = user_id AND role IN ('admin', 'manager')
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =====================================================
-- 6. ROW LEVEL SECURITY (RLS) POLICIES
-- =====================================================

-- Enable RLS on all tables
ALTER TABLE user_profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_permissions ENABLE ROW LEVEL SECURITY;
ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY;

-- User Profiles Policies
DROP POLICY IF EXISTS "Users can read own profile" ON user_profiles;
CREATE POLICY "Users can read own profile"
  ON user_profiles FOR SELECT
  USING (auth.uid() = id);

DROP POLICY IF EXISTS "Admins and managers can read all profiles" ON user_profiles;
CREATE POLICY "Admins and managers can read all profiles"
  ON user_profiles FOR SELECT
  USING (is_admin_or_manager(auth.uid()));

DROP POLICY IF EXISTS "Users can update own profile" ON user_profiles;
CREATE POLICY "Users can update own profile"
  ON user_profiles FOR UPDATE
  USING (auth.uid() = id);

DROP POLICY IF EXISTS "Admins can update any profile" ON user_profiles;
CREATE POLICY "Admins can update any profile"
  ON user_profiles FOR UPDATE
  USING (is_admin_user(auth.uid()));

DROP POLICY IF EXISTS "Users can insert own profile" ON user_profiles;
CREATE POLICY "Users can insert own profile"
  ON user_profiles FOR INSERT
  WITH CHECK (auth.uid() = id);

DROP POLICY IF EXISTS "Admins can delete profiles" ON user_profiles;
CREATE POLICY "Admins can delete profiles"
  ON user_profiles FOR DELETE
  USING (is_admin_user(auth.uid()));

-- User Permissions Policies
DROP POLICY IF EXISTS "Users can read own permissions" ON user_permissions;
CREATE POLICY "Users can read own permissions"
  ON user_permissions FOR SELECT
  USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "Admins can read all permissions" ON user_permissions;
CREATE POLICY "Admins can read all permissions"
  ON user_permissions FOR SELECT
  USING (is_admin_user(auth.uid()));

DROP POLICY IF EXISTS "Admins can manage permissions" ON user_permissions;
CREATE POLICY "Admins can manage permissions"
  ON user_permissions FOR ALL
  USING (is_admin_user(auth.uid()));

-- Audit Logs Policies
DROP POLICY IF EXISTS "Users can read own audit logs" ON audit_logs;
CREATE POLICY "Users can read own audit logs"
  ON audit_logs FOR SELECT
  USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "Admins can read all audit logs" ON audit_logs;
CREATE POLICY "Admins can read all audit logs"
  ON audit_logs FOR SELECT
  USING (is_admin_user(auth.uid()));

DROP POLICY IF EXISTS "Authenticated users can insert audit logs" ON audit_logs;
CREATE POLICY "Authenticated users can insert audit logs"
  ON audit_logs FOR INSERT
  WITH CHECK (auth.uid() IS NOT NULL);

-- =====================================================
-- 7. DEFAULT PERMISSIONS FUNCTION
-- =====================================================
-- Function to initialize default permissions for new users
CREATE OR REPLACE FUNCTION initialize_user_permissions(p_user_id UUID, p_role VARCHAR)
RETURNS VOID AS $$
DECLARE
  v_screens TEXT[] := ARRAY[
    'dashboard', 'members', 'payments', 'transactions', 
    'dividends', 'reports', 'projects', 'settings', 
    'user_management', 'master_data'
  ];
  v_screen TEXT;
BEGIN
  FOREACH v_screen IN ARRAY v_screens
  LOOP
    INSERT INTO user_permissions (user_id, screen_name, can_read, can_write, can_manage)
    VALUES (
      p_user_id,
      v_screen,
      CASE 
        WHEN p_role = 'admin' THEN true
        WHEN p_role = 'manager' THEN true
        WHEN p_role = 'member' AND v_screen IN ('dashboard', 'members', 'payments', 'transactions', 'reports') THEN true
        ELSE false
      END,
      CASE 
        WHEN p_role = 'admin' THEN true
        WHEN p_role = 'manager' AND v_screen NOT IN ('user_management', 'settings') THEN true
        ELSE false
      END,
      CASE 
        WHEN p_role = 'admin' THEN true
        ELSE false
      END
    )
    ON CONFLICT (user_id, screen_name) DO NOTHING;
  END LOOP;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =====================================================
-- 8. PERMISSION CHECK FUNCTIONS
-- =====================================================

-- Function to check if user has specific permission
-- Admins automatically have all permissions
CREATE OR REPLACE FUNCTION has_permission(
  p_user_id UUID,
  p_screen VARCHAR,
  p_permission_type VARCHAR -- 'read', 'write', or 'manage'
)
RETURNS BOOLEAN AS $$
DECLARE
  v_user_role VARCHAR;
  v_has_permission BOOLEAN := false;
BEGIN
  -- Check if user is admin first
  SELECT role INTO v_user_role FROM user_profiles WHERE id = p_user_id;
  
  -- Admins have complete access to everything
  IF v_user_role = 'admin' THEN
    RETURN true;
  END IF;
  
  -- For non-admins, check permissions table
  SELECT 
    CASE p_permission_type
      WHEN 'read' THEN can_read
      WHEN 'write' THEN can_write
      WHEN 'manage' THEN can_manage
      ELSE false
    END INTO v_has_permission
  FROM user_permissions
  WHERE user_id = p_user_id AND screen_name = p_screen;
  
  RETURN COALESCE(v_has_permission, false);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to get user role
CREATE OR REPLACE FUNCTION get_user_role(p_user_id UUID)
RETURNS VARCHAR AS $$
DECLARE
  v_role VARCHAR;
BEGIN
  SELECT role INTO v_role
  FROM user_profiles
  WHERE id = p_user_id;
  
  RETURN COALESCE(v_role, 'member');
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =====================================================
-- 9. SAMPLE DATA (Optional - for testing)
-- =====================================================
-- Uncomment to insert sample admin user
-- Note: Replace with actual user ID from auth.users after signup

/*
-- Insert sample admin profile
INSERT INTO user_profiles (id, name, email, role)
VALUES (
  'YOUR_AUTH_USER_ID_HERE',
  'Admin User',
  'admin@example.com',
  'admin'
)
ON CONFLICT (id) DO NOTHING;

-- Initialize permissions for admin
SELECT initialize_user_permissions('YOUR_AUTH_USER_ID_HERE', 'admin');
*/

-- =====================================================
-- 10. MAINTENANCE QUERIES
-- =====================================================

-- View to see all users with their permission counts
CREATE OR REPLACE VIEW v_user_permission_summary AS
SELECT 
  up.id,
  up.name,
  up.email,
  up.role,
  up.last_login,
  COUNT(perm.id) as total_permissions,
  SUM(CASE WHEN perm.can_read THEN 1 ELSE 0 END) as read_permissions,
  SUM(CASE WHEN perm.can_write THEN 1 ELSE 0 END) as write_permissions,
  SUM(CASE WHEN perm.can_manage THEN 1 ELSE 0 END) as manage_permissions
FROM user_profiles up
LEFT JOIN user_permissions perm ON up.id = perm.user_id
GROUP BY up.id, up.name, up.email, up.role, up.last_login;

-- View to see recent audit activity
CREATE OR REPLACE VIEW v_recent_audit_activity AS
SELECT 
  al.id,
  al.action,
  al.table_name,
  al.record_id,
  al.created_at,
  up.name as user_name,
  up.email as user_email,
  up.role as user_role
FROM audit_logs al
LEFT JOIN user_profiles up ON al.user_id = up.id
ORDER BY al.created_at DESC
LIMIT 100;

-- =====================================================
-- END OF SCHEMA
-- =====================================================
